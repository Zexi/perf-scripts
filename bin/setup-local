#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'fileutils'

HOSTNAME = ENV['HOSTNAME'] || `hostname`.chomp
ENV["TT_SRC"] ||= File.dirname File.dirname File.realpath $PROGRAM_NAME
TT_SRC = ENV["TT_SRC"]

require "#{TT_SRC}/lib/yaml.rb"
require "#{TT_SRC}/lib/job.rb"
require "#{TT_SRC}/lib/distro-info.rb"
require "#{TT_SRC}/lib/install.rb"

TMP = '/tmp' + TT_SRC

if `whoami`.chomp != 'root'
  puts "Please run root to install packages"
  exit 1
end

$opt_hdd = []
$opt_ssd = []

opts = OptionParser.new do |opts|
  opts.banner = 'Usage: setup-local [options] <script>/<jobfile>'

  opts.separator ''
  opts.separator 'options:'

  opts.on('--hdd partition', 'HDD partition for IO tests') do |hdd|
    $opt_hdd << hdd
  end

  opts.on('--ssd partition', 'SSD partition for IO tests') do |ssd|
    $opt_ssd << ssd
  end

  opts.on_tail('-h', '--help', 'Show this message') do
    puts opts
    exit
  end
end

if ARGV == []
  argv = ['-h']
else
  argv = ARGV
end
opts.parse!(argv)

scripts = []
ARGV.each { |arg|
  if arg =~ /.yaml/
    job = Job.new
    job.load(arg)

    job.each_program("{daemon,tests,setup,monitors}/**/*") { |k, v|
      scripts << k
    }
  elsif File.executable? arg
    scripts << arg.split('/')[-1]
  end
}

if scripts.empty?
  puts "No valid script or jobfile specified"
  exit 1
end
scripts.uniq!

def make_wakeup
  return if File.executable? TT_SRC + '/monitors/event/wakeup'
  system "cd #{TT_SRC}/monitors/event && make wakeup"
end

def create_tt_dirs
  FileUtils.mkdir_p TMP
  FileUtils.mkdir_p "/tmp/tt/paths"
  FileUtils.mkdir_p "/tmp/tt/benchmarks"
end

def create_host_config
  host_config = TT_SRC + "/hosts/#{HOSTNAME}"
  if File.exist? host_config
    puts "reusing " + host_config
  else
    mem_kb = File.open('/proc/meminfo').gets.split[1].to_i
    mem_gb = mem_kb >> 20
    mem_gb = (mem_gb + 3) & 0xfffffffc
    File.open(host_config, mode='w') { |file|
      file.puts "memory: #{mem_gb}G"
      file.puts "hdd_partitions: #{$opt_hdd.join ' '}"
      file.puts "ssd_partitions: #{$opt_ssd.join ' '}"
    }
  end
end

def install_debian_packages(script)
  packages = get_dependency_packages 'debian', script
  return unless packages

  unless system 'apt-get', 'install', '-y', *packages
    puts "Cannot install some packages in #{TT_SRC}/distro/debian/#{script}"
    exit 1
  end
end

def install_archlinux_packages(script)
  packages = get_dependency_packages "archlinux", script
  return unless packages

  # yaourt not support root to build package
  regular_user = `grep 1000 /etc/passwd | awk -F':' '{print $1}'`.chomp

  unless system 'sudo', '-u', "#{regular_user}", 'yaourt', '-S', '--noconfirm', *packages
    puts "Cannot install some packages in #{TT_SRC}/distro/archlinux/#{script}"
    exit 1
  end
end

def install_packages(script, distro)
  send("install_#{distro}_packages", script)
  send("install_#{distro}_packages", script + '-dev')
end

def install_benchmarks(script, distro)
  case distro
  when "debian"
    if File.file? "#{TT_SRC}/pack/#{script}"
      deb_name = script.gsub(/-/, '-') + '-TT.deb'
      puts "Making #{deb_name}..."
      if system "#{TT_SRC}/bin/pack -c #{script}"
        puts "Installing #{deb_name}..."
      #      system "dpkg -i /tmp/#{deb_name}"
      else
        puts "Making #{deb_name} failed"
      end
    end
  when "archlinux"
    if File.file? "#{TT_SRC}/pack/#{script}"
      puts "Making #{script} benchmarks for #{distro}"
      if system "#{TT_SRC}/bin/pack -c #{script}"
	puts "Making successfully"
      else
	puts "Making #{script} benchmarks failed"
      end
    end
  else
    puts "Unsupport #{distro} distribution"
  end
end

distroInfo = TT::DistroInfo.instance

case distroInfo.systemNameL
when  "debian"
  distro = "debian"
when "arch"
  distro = "archlinux"
else
  puts "Unsupport system, cannot install packages under #{TT_SRC}/distro/#{distro}"
  exit 1
end

make_wakeup
create_tt_dirs
create_host_config
install_packages("tt", distro)
install_packages("makepkg", distro)

scripts.each { |script|
   install_packages(script, distro)
   install_benchmarks(script, distro)
}
